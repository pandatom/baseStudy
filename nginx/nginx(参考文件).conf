# 用于配置Nginx生成工作进程的数量 建议将该值和服务器CPU的内核数保存一致
worker_processes  1;

# 指定Nginx服务器的worker进程的用户和用户组
user www;

# daemon：设定Nginx是否以守护进程的方式启动
daemon on;

# error_log:用来配置Nginx的错误日志存放路径
error_log logs/error.log error;

# pid:用来配置Nginx当前master进程的进程号ID存储的文件路径
pid /usr/local/nginx/logs/nginx.pid

# include:用来引入其他配置文件，使Nginx的配置更加灵活
include /usr/local/nginx/conf/xxx.conf


#events块,主要设置,Nginx服务器与用户的网络连接,这一部分对Nginx服务器的性能影响较大
events {
    worker_connections  1024;

    # accept_mutex:用来设置Nginx网络连接序列化 accept_mutex on |off;
    accept_mutex on;

    # multi_accept:用来设置是否允许同时接收多个网络连接 multi_accept on|off;
    multi_accept off;

    # worker_connections：用来配置单个worker进程最大的连接数 worker_connections number;
    worker_commections 512;

    # use:用来设置Nginx服务器选择哪种事件驱动来处理网络消息 根据操作系统定
    use epoll;

}

#http块，是Nginx服务器配置中的重要部分，代理、缓存、日志记录、第三方模块配置...  
http {
    # 定义够识别前端请求的资源类型
    include       mime.types;

    # default_type:用来配置Nginx响应前端请求默认的MIME类型 这里也可以设置成text/plain
    default_type  application/octet-stream;

    # access.log:用来记录用户所有的访问请求 access_log path[format[buffer=size]]
    access_log logs/access.log combined;

    # log_format:用来指定日志的输出格式 log_format name [escape=default\|json\|none] string....;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    # sendfile:用来设置Nginx服务器是否使用sendfile()传输文件，该属性可以大大提高Nginx处理静态资源的性能
    sendfile        on;

    # tcp_nopush：该指令必须在sendfile打开的状态下才会生效，
    #主要是用来提升网络包的传输'效率' tcp_nopush on\|off;
    tcp_nopush on;

    # tcp_nodelay：该指令必须在keep-alive连接开启的情况下才生效，
    #来提高网络包传输的'实时性' tcp_nodelay on\|off;
    tcp_nodeplay on;

    # 压缩设置
    # gzip指令：该指令用于开启或者关闭gzip功能 gzip on|off;
    gzip on;

    # gzip_types指令：该指令可以根据响应页的MIME类型选择性地开启Gzip压缩功能 gzip_types mime-type
    gzip_types application/javascript;

    # gzip_comp_level指令：该指令用于设置Gzip压缩程度，级别从1-9,
    #1表示要是程度最低，要是效率最高，9刚好相反，压缩程度最高，但是效率最低最费时间
    gzip_comp_level 6;

    # gzip_vary 该指令用于设置使用Gzip进行压缩发送是否携带“Vary:Accept-Encoding”
    #头域的响应头部。主要是告诉接收方，所发送的数据经过了Gzip压缩处理 gzip_vary on\|off;
    gzip_vary off;

    # gzip_buffers指令：该指令用于处理请求压缩的缓冲区数量和大小 gzip_buffers number size;
    gzip_buffers 4 16K;   #缓存空间大小

    # gzip_disable指令：针对不同种类客户端发起的请求，可以选择性地开启和关闭Gzip功能
    gzip_disable "MSIE [1-6]\.";

    # gzip_http_version指令：针对不同的HTTP协议版本，可以选择性地开启和关闭Gzip功能
    gzip_http_version 1.1;

    # gzip_min_length指令：该指令针对传输数据的大小，可以选择性地开启和关闭Gzip功能
    gzip_min_length 20; # gzip_min_length length;

    # gzip_proxied指令：该指令设置是否对服务端返回的结果进行Gzip压缩
    gzip_proxied off;

    # gzip_static: 检查与访问资源同名的.gz文件时，response中以gzip相关的header返回.gz文件的内容。
    # **gzip_static** on \| off \| always;
    gzip_static off;

    # 缓存
    # expires:该指令用来控制页面缓存的作用。可以通过该指令控制HTTP应答中的“Expires"和”Cache-Control"
    expires off; # expires   [modified] time  或者 expires epoch\|max\|off;

    # add_header指令是用来添加指定的响应头和响应值
    add_header= no-cache
    # 跨域设置
    add_header Access-Control-Allow-Origin *;
    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE;


    # 缓冲和缓存
    # proxy_buffering :该指令用来开启或者关闭代理服务器的缓冲区 proxy_buffering on|off;
    proxy_buffering on;

    # proxy_buffers:该指令用来指定单个连接从代理服务器读取响应的缓存区的个数和大小
    # proxy_buffers number size; 默认 proxy_buffers  4k | 8K;(与系统平台有关)
    proxy_buffers  8k

    # proxy_buffer_size:该指令用来设置从被代理服务器获取的第一部分响应数据的大小。
    #保持与proxy_buffers中的size一致即可，当然也可以更小
    proxy_buffer_size 4 32k;

    # proxy_temp_path:当缓冲区存满后，仍未被Nginx服务器完全接受，
    # 响应数据就会被临时存放在磁盘文件上，该指令设置文件路径 proxy_temp_path  path;


    # 该指令用来限制同时处于BUSY状态的缓冲总大小
    proxy_busy_buffers_size 64k;

    # proxy_temp_file_write_size：该指令用来设置磁盘上缓冲文件的大小 
    #proxy_temp_file_write_size size;
    proxy_temp_file_write_size 64k;


    # keepalive_timeout:用来设置长连接的超时时间
    keepalive_timeout  65;

    # keepalive_requests:用来设置一个keep-alive连接使用的次数
    keepalive_requests 100;

    upstream backend{
        server 192.168.1.12:8081 weight=1;
        server 192.168.1.12:8082 weight=2;
    }

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    # 负载均衡
    # upstream该指令是用来定义一组服务器，它们可以是监听不同端口的服务器，
    # 并且也可以是同时监听TCP和Unix socket的服务器。服务器可以指定不同的权重，默认为1
    upstream backend{
        #  server 该指令用来指定后端服务器的名称和一些参数，可以使用域名、IP、端口或者unix socket
        # 负载均衡状态
          # down当前的server暂时不参与负载均衡
          server 192.168.200.146:9001 down;
          # backup预留的备份服务器
          server 192.168.200.146:9002 backup;
          # max_fails允许请求失败的次数
          # fail_timeout经过max_fails失败后, 服务暂停时间
          server 192.168.200.133:9003 max_fails=3 fail_timeout=15;
          # max_conns限制最大的接收连接数

        # 负载均衡策略
          # 轮询默认方式
          # weight权重方式
          server 192.168.200.146:9001 weight=1;
          # ip_hash依据ip分配方式
            ip_hash;
            server 192.168.200.146:9001;
          # least_conn依据最少连接方式
            least_conn;
            server 192.168.200.146:9001;
          # url_hash依据URL分配方式 
            hash &request_uri;
            server 192.168.200.146:9001;
          # fair依据响应时间方式
            fair;
            server 192.168.200.146:9001;
        server 192.168.200.146:9091;
        server 192.168.200.146:9092;
        server 192.168.200.146:9093;
    }

    

    #server块，是Nginx配置和虚拟主机相关的内容
    server {
        # listen:用来配置监听端口
        listen       80;

        # server_name：用来设置虚拟主机服务名称 中可以使用正则表达式，并且使用`~`作为正则表达式字符串的开始标记
        server_name  localhost;

        # ssl 
        # 命令 ssl on \| off;
        listen 443 ssl;

        #ssl_certificate:为当前这个虚拟主机指定一个带有PEM格式证书的证书 ssl_certificate file;
        ssl_certificate      server.cert;

        # ssl_certificate_key 该指令用来指定PEM secret key文件的路径 ssl_ceritificate_key file;
        ssl_certificate_key  server.key;

        # ssl_session_cache:该指令用来配置用于SSL会话的缓存
        # ssl_sesion_cache off\|none\|[builtin[:size]] [shared:name:size]
        ssl_session_cache    shared:SSL:1m;

        # ssl_session_timeout：开启SSL会话功能后，设置客户端能够反复使用储存在缓存中的会话参数时间
        ssl_session_timeout  5m;

        # ssl_ciphers:指出允许的密码，密码指定为OpenSSL支持的格式
        # ssl_ciphers ciphers; 默认值 ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_ciphers  HIGH:!aNULL:!MD5;

        # ssl_prefer_server_ciphers：该指令指定是否服务器密码优先客户端密码
        ssl_prefer_server_ciphers  on; # ssl_perfer_server_ciphers on\|off;

        ##location块，基于Nginx服务器接收请求字符串与location后面的值进行匹配，对特定请求进行处理   
        location / {
            # root：设置请求的根目录
            root   /usr/share/nginx/html;

            # 和root一样：设置请求的根目录，alias也必须是以/结尾，root没有要求
            alias /usr/local/nginx/html/images;

            #error_page:设置网站的错误页面 error_page code ... [=[response]] uri;
            error_page 404 http://www.itcast.cn; 

             # Nginx防盗链 valid_referers:nginx会通就过查看referer自动和
             # valid_referers后面的内容进行匹配，如果匹配到了就将
             valid_referers none blocked www.baidu.com 192.168.200.222 *.example.com example.*  www.example.org  ~\.google\.;   

             # 该指令用来设置被代理服务器地址，可以是主机名称、IP地址加端口号形式 proxy_pass URL;
             proxy_pass http://192.168.200.146;

             # 该指令可以更改Nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器
              proxy_set_header username TOM; # proxy_set_header field value; 

             # proxy_redirect 该指令是用来重置头信息中的"Location"和"Refresh"的值。
             # proxy_redirect redirect replacement; 或者 proxy_redirect default; 
             # 或者 proxy_redirect off;
             proxy_redirect http://192.168.200.146 http://192.168.200.133;



            index  index.html index.htm;
        }
    }

    # 使用location的@符合完成错误信息展示
    server{
    error_page 404 @jump_to_error;
    location @jump_to_error {
        default_type text/plain;
        return 404 'Not Found Page...';
        }
    }

    # 缓存
    # proxy_cache_path 该指定用于设置缓存文件的存放路径
    proxy_cache_path /usr/local/proxy_cache levels=2:1 keys_zone=itcast:200m inactive=1d max_size=20g;

    upstream backend{
        server 192.168.200.146:8080;
    }

    server {
        listen       8080;
        server_name  localhost;
        location / {
            # proxy_cache 该指令用来开启或关闭代理缓存，如果是开启则自定使用哪个缓存区来进行缓存
            proxy_cache itcast; # proxy_cache zone_name|off; 

            # proxy_cache_key 该指令用来设置web缓存的key值，Nginx会根据key值MD5哈希存缓存
            proxy_cache_key itheima;

            # proxy_cache_min_uses 该指令用来设置资源被访问多少次后被缓存
            proxy_cache_min_uses 5;

            # proxy_cache_valid 该指令用来对不同返回状态码的URL设置不同的缓存时间
            proxy_cache_valid 200 5d;
            proxy_cache_valid 404 30s;
            proxy_cache_valid any 1m;

            # proxy_cache_methods 该指令用户设置缓存哪些HTTP方法
            proxy_cache_methods GET HEAD;  # proxy_cache_methods GET\|HEAD\|POST;


            add_header nginx-cache "$upstream_cache_status";
            proxy_pass http://backend/js/;
        }
    }

    # 缓存清除
    server{
    location ~/purge(/.*) {
        proxy_cache_purge itcast itheima;
        }
    }

    # 设置资源不缓存 位置：http、server、location
       # $cookie_nocache 指的是当前请求的cookie中键的名称为nocache对应的值
       # $arg_nocache和$arg_comment 指的是当前请求的参数中属性名为nocache和comment对应的属性值

    # proxy_no_cache   该指令是用来定义不将数据进行缓存的条件
    proxy_no_cache $cookie_nocache $arg_nocache $arg_comment;

    # proxy_cache_bypass 该指令是用来设置不从缓存中获取数据的条件
    proxy_cache_bypass $cookie_nocache $arg_nocache $arg_comment;

    # 不缓存列子 
    log_format params $cookie_nocache | $arg_nocache | $arg_comment；
    server{
        listen  8081;
        server_name localhost;
        location /{
            access_log logs/access_params.log params;
            add_header Set-Cookie 'nocache=999';
            root html;
            index index.html;
        }
    }

    server{
        listen  8080;
        server_name localhost;
        location / {
            if ($request_uri ~ /.*\.js$){
               set $nocache 1;
            }
            proxy_no_cache $nocache $cookie_nocache $arg_nocache $arg_comment;
        proxy_cache_bypass $nocache $cookie_nocache $arg_nocache $arg_comment;
        }
    }

}