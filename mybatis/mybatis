mybatis

1.就是个持久成的框架，google公司的，可以手写sql，开发比hibernate方便
  接口式编程
  mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。

2.参数，单个可以不用指定，多个需要指定
  1.多个可以用@param
  2.也可以使用pojo或者map--map按key来取值
  3.resultType返回类型
  映射文件指导着MyBatis如何进行数据库增删改查，有着非常重要的意义；
	cache –命名空间的二级缓存配置
	cache-ref – 其他命名空间缓存配置的引用。
	resultMap – 自定义结果集映射
	parameterMap – 已废弃！老式风格的参数映射
	sql –抽取可重用语句块。
	insert – 映射插入语句
	update – 映射更新语句
	delete – 映射删除语句
	select – 映射查询语句

3.databaseId指定使用哪个数据库
<select id="getEmpById" resultType="com.lun.c01.helloworld.bean.Employee"
	databaseId="mysql">
	select * from employee where id = #{id}
</select>

4.自增主键
 mysql
 <insert id="addEmp" parameterType="com.lun.c01.helloworld.bean.Employee"
		useGeneratedKeys="true" keyProperty="id" >
		insert into employee(last_name,email,gender) 
		values(#{lastName},#{email},#{gender})
 </insert>

oracle
	<insert id="addEmp" databaseId="oracle">
	<selectKey keyProperty="id" order="BEFORE" resultType="Integer">
		<!-- BEFORE-->
		select EMPLOYEES_SEQ.nextval from dual 
		<!-- AFTER-->
		 select EMPLOYEES_SEQ.currval from dual -->
	</selectKey>
	
	<!-- 插入时的主键是从序列中拿到的 -->
	<!-- BEFORE:-->
	insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) 
	values(#{id},#{lastName},#{email<!-- ,jdbcType=NULL -->}) 
	<!-- AFTER:-->
	insert into employees(EMPLOYEE_ID,LAST_NAME,EMAIL) 
	values(employees_seq.nextval,#{lastName},#{email})
</insert>

5.	@MapKey:告诉mybatis封装这个map的时候使用哪个属性作为map的key
	@Param
	public Employee getEmp(@Param("id")Integer id,String lastName);

	<select id="getEmpByIdReturnMap" resultType="map">
 		select * from employee where id=#{id}
 	</select>


6.参数处理-#与$取值区别#{} : 		                                           是以预编译的形式，将参数设置到sql语句中；PreparedStatement；防止sql注入
	${} : 取出的值直接拼装在sql语句中；会有安全问题；
	大多情况下，我们去参数的值都应该去使用#{}。

	原生jdbc不支持占位符的地方我们就可以使用${}进行取值，比如分表、排序。。。；按照年份分表拆分


7.jdbcType通常需要在某种特定的条件下被设置：
	在我们数据为null的时候，有些数据库可能不能识别mybatis对null的默认处理。比如Oracle DB（报错）；
	JdbcType OTHER：无效的类型；因为mybatis对所有的null都映射的是原生Jdbc的OTHER类型，Oracle DB不能正确处理;
	由于全局配置中：jdbcTypeForNull=OTHER，Oracle DB不支持，两种解决方法：

	在mapper文件中写#{email,jdbcType=NULL};
	在全局配置文件<setting name="jdbcTypeForNull" value="NULL"/>

8.resultMap
   association可以实现分步查询，有了分步查询就可以做懒加载查询
   - property 查询对象名称
   - select 分步查询的引用
   - oftype 返回结果类型

   懒加载 		
   <setting name="lazyLoadingEnabled" value="true"/>
	fetchType=“lazy”：表示使用延迟加载；
	lazy：延迟
	eager：立即


9.动态sql
	where
	<if test="">
	<tirm prefix="" prefixOverrides="" suffix="" suffixOverride="">
	<choose> <when> <otherwise>
	<foreach collection="epms" item="emp" separator=','/>

10.缓存：
   一级缓存，默认开启
   二级缓存：手动开启，一般都是使用第三方来实现cache接口使用
   都是可以在set环境变量配置，或者单独mapping.xml文件的指定sql标签上指定是否开启

  	 缓存
  一级缓存失效的四种情况：
	不同的SqlSession对应不同的一级缓存
	同一个SqlSession但是查询条件不同
	同一个SqlSession两次查询期间执行了任何一次增删改操作
	同一个SqlSession两次查询期间手动清空了缓存

	二级缓存(second level cache)，全局作用域缓存
	二级缓存默认不开启，需要手动配置
	MyBatis提供二级缓存的接口以及实现，缓存实现要求 POJO实现Serializable接口
	二级缓存在 SqlSession 关闭或提交之后才会生效

11.工作原理
	代码先是去读取xml配置文件内容，读取环境配置内容，在读取mapping映射文件内容，然后放到一个对象中返回，封装了我们的statementhandle
	返回的对象创建executor对象，
	执行statementhandle设置参数用到parametehandle处理结果的时候用到resultestHandle
	而parameterhandle和resultsethandle有需要typehandle来实现javabean和数据库类型的映射，如此完成整个操作流程

	Executor：更新，查询，事务，刷新，开，关，这些的执行器
	StatementHandler：处理sql语句预编译，设置参数等相关工作；
	ParameterHandler：设置预编译参数用的
	ResultHandler：处理结果集
	TypeHandler：在整个过程中，进行数据库类型和javaBean类型的映射


12.四个核心组件
	Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
		1.创建executor
		2.是否创建缓存
		3.调用拦截器，如果代码调用的有就进入拦截器，没有就不操作
		4.返回deflautsqlSession对象
	ParameterHandler (getParameterObject, setParameters)
	设置预编译参数用的

	ResultSetHandler (handleResultSets, handleOutputParameters)
	1.返回数据集
	StatementHandler (prepare, parameterize, batch, update, query)
	1.创建预编译

2.创建一个拦截器链
	默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：
	Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
	ParameterHandler (getParameterObject, setParameters)
	ResultSetHandler (handleResultSets, handleOutputParameters)
	StatementHandler (prepare, parameterize, batch, update, query)

	Interceptor接口
		Intercept：拦截目标方法执行
		plugin：生成动态代理对象，可以使用MyBatis提供的Plugin类的wrap方法
		setProperties：注入插件配置时设置的属性

	实现步骤：

	1.编写插件实现Interceptor接口
	  实现方法 1.intercept 拦截方法
	          2.plugin 通过代理方式指定代理插件对象
	          3.setProperties配置文件加载信息，这个方法先执行
	2.实现接口 @Intercepts注解完成插件签名 
	  需要指定插件拦截组件，组件的里面的那个方法，方法的参数
	  @Signature(type=StatementHandler.class,method="parameterize",args=java.sql.Statement.class)
	
	2.在全局配置文件中注册插件
	<configuration>
		<plugins>
			<plugin interceptor="com.lun.c08.interceptor.MyFirstPlugin">
				<properties>这里配个properties数据<properties>
			</plugin>
			<!-- 可实现多个插件 -->
			<plugin interceptor="com.lun.c08.interceptor.MySecondPlugin"></plugin>
		</plugins>
	...




批量保存
	openSession 方法的 ExecutorType 类型的参数，枚举类型:
	ExecutorType.SIMPLE: 这个执行器类型不做特殊的事情（这是默认装配的）。它为每个语句的执行创建一个新的预处理语句。
	ExecutorType.REUSE: 这个执行器类型会复用预处理语句。
	ExecutorType.BATCH: 这个执行器会批量执行所有更新语句

	SqlSession openSession = sqlSessionFactory.openSession(ExecutorType.BATCH);


	//批量：（预编译sql一次==>设置参数===>10000次===>执行（1次））
	//Parameters: 616c1(String), b(String), 1(String)==>4598
	//非批量：（预编译sql=设置参数=执行）==》10000    10200

	与Spring整合中，我们推荐，额外的配置一个可以专门用来执行批量操作的SqlSession
	<!--配置一个可以进行批量执行的sqlSession  -->
	<bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate">
		<constructor-arg name="sqlSessionFactory" ref="sqlSessionFactoryBean"></constructor-arg>
		<constructor-arg name="executorType" value="BATCH"></constructor-arg>
	</bean>
    
    
    spring中注入使用
    @Autowired
	private SqlSession sqlSession;


	插件是MyBatis提供的一个非常强大的机制，我们可以通过插件来修改MyBatis的一些核心行为。 插件通过动态代理机制，可以介入四大对象的任何一个方法的执行。

	了解mybatis运行原理才能更好开发插件。

面试题
1. 最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？
　　答：Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。

　　Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。

　　Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。



3、简述Mybatis的插件运行原理，以及如何编写一个插件。
　　答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。

实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。


8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？
答：Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。

11、Mybatis都有哪些Executor执行器？它们之间的区别是什么？
答：Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。

SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。

ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map<String, Statement>内，供下一次使用。简言之，就是重复使用Statement对象。

BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。

作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。

12、Mybatis中如何指定使用哪一种Executor执行器？
答：在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。

13、Mybatis是否可以映射Enum枚举类？
答：Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。

24. 简述Mybatis的插件运行原理，以及如何编写一个插件
　　Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。

　　实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。



mybatis使用到外观模式---Configuration 类相当于外观类，对客户端（调用方）提供统一接口

---------------------------------------------------------------------------
1.mapper namespace id parameterType resultType 
	insert useGeneratekeys keyproperty 
	databaseId association--property--javatype
	映射文件-select-resultMap-关联查询-association分步查询
	映射文件-select-resultMap-关联查询-collection分步查询&延迟加载

	association可以指定联合的javaBean对象
		property="dept"：指定哪个属性是联合的对象
		javaType:指定这个属性对象的类型[不能省略]

	collection定义关联集合类型的属性的封装规则 
	全局配置文件--引入dtd约束
	类型别名。它们都是大小写不敏感的
    databaseIdProvider-多数据库支持			
    ofType:指定集合里面元素的类型





----------------------------------mybatisPlus--------------------------------------


查看： https://mp.baomidou.com/guide/interceptor.html

1.注意定义实体类使用包装类型，这样对于空默认一般是null。便于统一管理

2.整合
   1.搭建一个简单的mybatis工程
   2.在spring的xml中bean注入的mybatis替换成mybatisplus的引用即可

3.mybatisplus的crud
   1.mp中不需要mapping.xml，只需要接口继承baseMaping<object>
   2.@TableID指定字段为主键，value-- 主键字段名称 type;指定是自增策略
   3.@TableNamme 在我们Javabean上使用指定关联的表名 value-- 指定表名
   4.mp的全局策略配置，
      比如驼峰命名、使用数据库、别名。全局的主键配置策略、全局的数据库表名配置策略等
   5.@TableField 指定表字段名称 value 具体数据库表字段名称
     如果javabean有些字段不在表中可以@Tablefield(exist=false)
   6.插入主键 

4.MP在启动的时候就会分析好xxxMapp接口分析处理好方法对应的文件生成好sql

5.使用AR操作的crud
  1.javabean继承Model<Objext>
  2.实现pkVal()方法 返回当前版本的主键属性

6.mybatis的四大对象
  exector、perstatment、handle、resultset

  1.定义一个插件
    1.实现implement Intercepter
    2.给拦截插件配置签名
      @Intercepts({@signature(type=statmenthanler.class,method=parpre，args={connection.class,integer.class})})
      签名里面指定
      1.type: 指定拦截四大对象的那个对象
      2.method: 指定拦截这个对象里面的那个参数
      3.args:指定方法需要传入的参数个数和类型

    2.注册插件
       1.在spring的xml文件中注册插件配置
       2.乐观锁插件：
          就是给表加上一个版本号的字段，使用版本号来保证数据操作隔离性
          1.javabean 加一个private Integer version；加上一个注解@version
          2.数据库也加上version这个字段
          2.1 配置文件加入版本插件的配置 
          3.写个测试类来测试
              哪一个版本号和数据库的版本号不一样的来做更新操作


7.自定义的全局操作
   如果想要写一个sql在项目加载的时候就加载在mapping中
   使用autosqlInjector

   自定义全局操作
   1.新建一个类extends autosqlinjector
   2.实现inject方法
   3.spring的配置文件先注入定义的注入器并加入到mybatis的配置中
   4.将对象定义的方法，处理成对应的mappedStatement对象，加入到configuration对象中
       1.定义写的slq
       2.定义方法名称
       3.构造sqlsource对象
       4.构造一个对象sql语句的statement对象加入configuration


   1.自定义逻辑删除
      1.spring的xml注入逻辑删除的路径对象
      2.数据库表新加一个逻辑删除字段
      3.javabean逻辑删除字段加上字段@TableLogic
      4.配置文件里面要指定逻辑的删除值
     -- 逻辑删除底层不是delette操作，而是update操作修改逻辑字段状态而已
   

 8.公共字段填充
   给有些没有填值的字段加上默认值

   1.在我们需要填充的的字段上加上注解
     @TableField(fill=Fieldfill.Xxxx)
   2.自定义填充类--设置自动填充自己定义的值
     extends metaObjecthandle
     实现方法一个是插入自填充，一个是更新自动填充
   3.spring的配置文件注入自定义的填充器。mybatis全局配置里面也要注入

9.对于oracle的squence
   1.oracle创建表的主键序列 
   2.在javabean类上加上@keySequence(value=数据库中的序列，clazz=Integer.class)
   3.主键字段上加上@TableField(fill=fieldfill.insert_update) 如果不想配置，可以直接配置成
   全局的，这样操作oracle的主键字段都不用配置
	    配置全局：1.在spring中注入oracel的sequence和注入到mybatis中
   4.如果好几个对象用的同一个序列，不想每个类都加上@keySequence，可以给这些类加一个父类，这些类来
   继承父类即可。
	    

新版本已经没有entitywrapper了,用queryWrapper代替了


-----------------------------------------------


多表参考

<resultMap type="com.bean.Employee" id="MyEmpStep">
 		...
 		<!-- 定义关联对象的封装规则 
 			select：表明当前属性是调用select指定的方法查出的结果
 			column：指定将哪一列的值传给这个方法
 		-->
 		<association property="dept"
 		select="com.dao.DepartmentMapper.getDeptById"
 		column="d_id">
 		</association>
</resultMap>
    
<select id="getEmpByIdStep" resultMap="MyEmpStep">
 	select * from tbl_employee where id = #{id}
</select>

要是在使用association或者collection时需要将多个列的值传递给调用的方法，可以将多列的值封装到map中进行传递column="{key1 = column1, key2 = column2}"

<collection property="emps" select="com.dao.EmployeeMapperPlus.getEmpsByDeptId"
		column="{deptId = id}">
</collection>


参考：
/Users/mac/Desktop/workspace/qdnz-jw/jw-system/src/main/resources/mapper/project/CaseSurveyMapper.xml

/Users/mac/Desktop/workspace/qdnz-jw/jw-system/src/main/resources/mapper/project/DutyGroupMapper.xml







































